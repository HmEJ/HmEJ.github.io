<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      
        <title>win11professionalactive</title>
      
      <link href="/2024/09/22/win11professionalactive/"/>
      <url>/2024/09/22/win11professionalactive/</url>
      
        <content type="html"><![CDATA[<h1 id="win11-kms激活"><a href="#win11-kms激活" class="headerlink" title="win11 kms激活"></a>win11 kms激活</h1><p>kms服务器 <code>kms.03k.org</code>     2024.8.30 测试可行</p><p>在<code>powershell</code>或<code>cmd</code>中键入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX</span><br><span class="line">slmgr /skms kms.03k.org</span><br><span class="line">slmgr /ato</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 其他 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> win11专业版激活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>自用工具合集</title>
      
      <link href="/2024/08/11/%E8%87%AA%E7%94%A8%E5%B7%A5%E5%85%B7%E5%90%88%E9%9B%86/"/>
      <url>/2024/08/11/%E8%87%AA%E7%94%A8%E5%B7%A5%E5%85%B7%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p>本文记录我收藏的一些 有趣🤡|生产力🆙|独特🧐 的开源工具。基本上都是我正在使用的工具。</p><h2 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h2><h3 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h3><blockquote><p>客制化shell终端。多种主题任选</p></blockquote><p><a href="https://github.com/ohmyzsh/ohmyzsh">github</a></p><h3 id="sdkman"><a href="#sdkman" class="headerlink" title="sdkman"></a>sdkman</h3><blockquote><p>linux，macos上的绝佳sdk管理工具</p></blockquote><p><a href="https://github.com/sdkman/sdkman-cli">github</a></p><h3 id="scoop"><a href="#scoop" class="headerlink" title="scoop"></a>scoop</h3><blockquote><p>win上的绝佳sdk&#x2F;软件管理工具</p></blockquote><p><a href="https://github.com/ScoopInstaller/Scoop">github</a></p><h3 id="lazydocker"><a href="#lazydocker" class="headerlink" title="lazydocker"></a>lazydocker</h3><blockquote><p>管理docker的TUI，支持鼠标点击</p></blockquote><p><a href="https://github.com/jesseduffield/lazydocker">github</a></p><h3 id="lazygit"><a href="#lazygit" class="headerlink" title="lazygit"></a>lazygit</h3><blockquote><p>管理git的TUI，支持鼠标点击</p></blockquote><p><a href="https://github.com/jesseduffield/lazygit">github</a></p><h3 id="fd"><a href="#fd" class="headerlink" title="fd"></a>fd</h3><blockquote><p>一个简单，快速，友好的 “find” 命令替代</p></blockquote><p><a href="https://github.com/sharkdp/fd">github</a></p><h2 id="WEB-桌面"><a href="#WEB-桌面" class="headerlink" title="WEB|桌面"></a>WEB|桌面</h2><h3 id="tabby"><a href="#tabby" class="headerlink" title="tabby"></a>tabby</h3><blockquote><p>ssh客户端。Termius平替</p></blockquote><p><a href="https://github.com/Eugeny/tabby">github</a></p><h3 id="excalidraw"><a href="#excalidraw" class="headerlink" title="excalidraw"></a>excalidraw</h3><blockquote><p>手绘风格的开源画板</p></blockquote><p><a href="https://github.com/excalidraw/excalidraw">github</a></p><h3 id="drawio"><a href="#drawio" class="headerlink" title="drawio"></a>drawio</h3><blockquote><p>UML画图工具。Processon平替</p></blockquote><p><a href="https://github.com/jgraph/drawio">github</a></p><h3 id="screenshot-to-code"><a href="#screenshot-to-code" class="headerlink" title="screenshot-to-code"></a>screenshot-to-code</h3><blockquote><p>通过截图生成前端页面代码</p></blockquote><p><a href="https://github.com/abi/screenshot-to-code">github</a></p><h3 id="marktext"><a href="#marktext" class="headerlink" title="marktext"></a>marktext</h3><blockquote><p>markdown编辑器。Typora平替</p></blockquote><p><a href="https://github.com/marktext/marktext">github</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自用工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>git checkout检出文件</title>
      
      <link href="/2024/07/18/article5/"/>
      <url>/2024/07/18/article5/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>git checkout的作用通常有两个：</p><ul><li>切换到指定分支或者commit</li><li>从指定分支或commit中恢复文件到当前工作目录</li></ul><p>第一个作用大家都很清楚，通过 <code>git checkout &lt;branch&gt;|&lt;commit id&gt;</code> 很轻松能做到。本文重点记录第二个作用，也就是检出文件的作用。</p><h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>我学习项目的时候通常喜欢在README.md中记录笔记。然后现在我希望将当前项目的版本回退到前一个版本，但是同时我又希望只保留当前版本的 README.md中的新增笔记内容。</p><p>如果直接使用 <code>git revert &lt;commit id&gt;</code>  那么会直接恢复到前一个版本，但是随之而来的，我的新增的笔记内容会消失。使用 <code>git reset</code> 也是一样。下方git树图示将展示我希望git树的变化:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前git树：</span></span><br><span class="line">a (HEAD -&gt; main)</span><br><span class="line">|</span><br><span class="line">b</span><br><span class="line">|</span><br><span class="line">c</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">希望的git树：(回退版本，但是保留特定文件)</span></span><br><span class="line">b (HEAD -&gt; main)</span><br><span class="line">|</span><br><span class="line">c</span><br></pre></td></tr></table></figure><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>通过 <code>git checkout</code> 检出文件的功能，可以实现此目的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &lt;branch&gt; -- &lt;file&gt; ...</span><br></pre></td></tr></table></figure><p>新建一个临时分支，这个分支保留了主分支最新的提交。然后在主分支执行回滚操作，回滚到指定的版本。然后通过<code>git checkout</code> 的文件检出功能，将之前的临时分支中最新的文件内容检出到当前分支。就实现了 ”版本回退但是保留特定文件最新状态“ 的目的。</p><p>具体流程如下：</p><h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><ol><li><p>新建一个临时分支，该分支会保存当前分支的所有最新提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b temp-branch</span><br></pre></td></tr></table></figure><p>此时，我们的git树会像这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前git树：</span></span><br><span class="line">a temp-branch(HEAD -&gt; temp-branch)</span><br><span class="line">|/</span><br><span class="line">b</span><br><span class="line">|</span><br><span class="line">c</span><br></pre></td></tr></table></figure></li><li><p>此时temp-branch相当于main分支的备份。我们现在可以放心的回滚main分支的提交了。回滚提交到指定的版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到main分支的最新提交（a提交）</span></span><br><span class="line">git checkout main</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重置HEAD到b</span></span><br><span class="line">git reset --hard b </span><br></pre></td></tr></table></figure><p>此时，我们的git树会像这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当前git树：</span></span><br><span class="line">a temp-branch</span><br><span class="line">|/</span><br><span class="line">b (HEAD -&gt; main)</span><br><span class="line">|</span><br><span class="line">c</span><br></pre></td></tr></table></figure></li><li><p>此时README文件中的内容也一同回滚到b的版本了，但是别担心，我们可以使用<code>git checkout</code> 指令来恢复文件。</p><p>还记得<code>temp-branch</code>分支吗？他是main分支最新提交的备份，该分支中保存了a提交中的最新内容。因此，我们使用<code>git checkout</code> 来从<code>temp-branch</code>分支中恢复内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将temp-branch分支中的README.md检出到当前版本中</span></span><br><span class="line">git checkout temp-branch -- README.md</span><br></pre></td></tr></table></figure><p>假如现在我改变了想法，我除了想保留README.md，还想保留之前版本的所有yml文件，那么可以这样写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout temp-branch -- README.md $(find ./ -name &#x27;*.yml&#x27;)</span><br></pre></td></tr></table></figure><p>完成这一切后，删除这个临时分支（它已经发挥了它的作用）。我们的目的达到了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -d temp-branch</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>搭建git服务</title>
      
      <link href="/2024/07/07/article4/"/>
      <url>/2024/07/07/article4/</url>
      
        <content type="html"><![CDATA[<p>记录一下搭建git服务的过程（简单版）</p><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><h2 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h2><p>第一步，创建一个新的用户，是为了便于权限管理</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adduser git</span><br></pre></td></tr></table></figure><p>可以通过 <code>cat /etc/passwd</code> 查看当前系统的用户</p><h2 id="添加ssh公钥"><a href="#添加ssh公钥" class="headerlink" title="添加ssh公钥"></a>添加ssh公钥</h2><p>第二步，将客户端机器的ssh公钥（位于用户目录下的 .ssh 目录中）添加到服务器用户的 <code>.ssh/authorized_keys</code> 中。如果没有的话新建这个文件。</p><p>这一步的主要目的是为了能让客户端机器可以通过git访问服务器。</p><p>试着通过 <code>ssh git@&lt;服务器ip或域名&gt;</code> 来访问服务器，如果这里公钥添加成功了，是可以直接访问的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> .ssh &amp;&amp; <span class="built_in">cd</span> .ssh</span><br><span class="line"><span class="built_in">touch</span> authorized_keys</span><br></pre></td></tr></table></figure><h2 id="初始化一个远端仓库"><a href="#初始化一个远端仓库" class="headerlink" title="初始化一个远端仓库"></a>初始化一个远端仓库</h2><p>在 ~ 下新建一个远端仓库，通过 <code>git init --bare</code> 来初始化。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"><span class="built_in">mkdir</span> test.git &amp;&amp; <span class="built_in">cd</span> test.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure><h2 id="推送文件到远端仓库"><a href="#推送文件到远端仓库" class="headerlink" title="推送文件到远端仓库"></a>推送文件到远端仓库</h2><p>在客户端机器上克隆远端仓库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@&lt;ip/domain&gt;:test.git</span><br></pre></td></tr></table></figure><p>进行一些修改，然后推送。</p><hr><p>这样就实现了一个简易的git服务器了。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>win上超好用的包管理工具-scoop</title>
      
      <link href="/2024/06/26/article3/"/>
      <url>/2024/06/26/article3/</url>
      
        <content type="html"><![CDATA[<p>Linux 和 macOS 各有便捷的包管理工具。在 Ubuntu 上，可以通过 apt 轻松管理软件，使用 sdkman 管理开发环境。在 macOS 上，Homebrew 是一个流行的包管理工具，它同样可以轻松安装和管理各种软件包和开发环境。本文介绍的 Scoop 是一款适用于 Windows 系统的高效包管理工具，不仅能够安装众多软件，还能管理开发环境（如 Java 或 Node.js），从而避免因手动安装软件对系统目录造成污染。简直是强迫症患者福音！🤗</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>在powershell中执行以下命令：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Set-ExecutionPolicy</span> <span class="literal">-ExecutionPolicy</span> RemoteSigned <span class="literal">-Scope</span> CurrentUser</span><br><span class="line"><span class="comment"># 安装scoop</span></span><br><span class="line"><span class="built_in">Invoke-RestMethod</span> <span class="literal">-Uri</span> https://get.scoop.sh | <span class="built_in">Invoke-Expression</span></span><br></pre></td></tr></table></figure><blockquote><p>该命令使设备允许运行安装和管理脚本。这是必需的，因为默认情况下，Windows 10 客户端设备会限制任何 PowerShell 脚本的执行。</p></blockquote><p>scoop会被安装至 <code>C:\Users\&lt;YOUR USERNAME&gt;\scoop</code></p><p>安装完成后执行:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop help</span><br></pre></td></tr></table></figure><p>可以查看帮助信息</p><h2 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h2><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop uninstall scoop</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="查找软件"><a href="#查找软件" class="headerlink" title="查找软件"></a>查找软件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop search &lt;app&gt;</span><br></pre></td></tr></table></figure><p>例如： <code>scoop search jdk</code></p><p>你的控制台会输出：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Name                      Version                   Source Binaries</span><br><span class="line"><span class="literal">----</span>                      <span class="literal">-------</span>                   <span class="literal">------</span> <span class="literal">--------</span></span><br><span class="line">corretto<span class="literal">-jdk</span>              <span class="number">21.0</span>.<span class="number">3.9</span>.<span class="number">1</span>                java</span><br><span class="line">corretto<span class="literal">-lts-jdk</span>          <span class="number">17.0</span>.<span class="number">11.9</span>.<span class="number">1</span>               java</span><br><span class="line">corretto11<span class="literal">-jdk</span>            <span class="number">11.0</span>.<span class="number">23.9</span>.<span class="number">1</span>               java</span><br><span class="line">corretto15<span class="literal">-jdk</span>            <span class="number">15.0</span>.<span class="number">2.7</span>.<span class="number">1</span>                java</span><br></pre></td></tr></table></figure><p>scoop默认预装了 main 的bucket。 这里我们可以看到source是java， 因此如果想要安装jdk，我们需要添加java到bucket中。</p><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop install &lt;app&gt;</span><br></pre></td></tr></table></figure><p>scoop只能安装本地bucket中存在的软件。接上，如果想要安装jdk， 我们需要先将java源添加到bucket中。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop bucket add java</span><br></pre></td></tr></table></figure><p>之后执行 <code>scoop install corretto-jdk</code> 即可安装。</p><p>scoop目前已知的bucket有：</p><ul><li><a href="https://github.com/ScoopInstaller/Main">main</a> - <strong>Default bucket</strong> which contains popular non-GUI apps.</li><li><a href="https://github.com/ScoopInstaller/Extras">extras</a> - Apps that do not fit the main bucket’s <a href="https://github.com/ScoopInstaller/Scoop/wiki/Criteria-for-including-apps-in-the-main-bucket">criteria</a>.</li><li><a href="https://github.com/Calinou/scoop-games">games</a> - Open-source and freeware video games and game-related tools.</li><li><a href="https://github.com/matthewjberger/scoop-nerd-fonts">nerd-fonts</a> - Nerd Fonts.</li><li><a href="https://github.com/ScoopInstaller/Nirsoft">nirsoft</a> - A collection of over 250+ apps from <a href="https://nirsoft.net/">Nirsoft</a>.</li><li><a href="https://github.com/niheaven/scoop-sysinternals">sysinternals</a> - The Sysinternals suite from <a href="https://learn.microsoft.com/sysinternals/">Microsoft</a>.</li><li><a href="https://github.com/ScoopInstaller/Java">java</a> - A collection of Java development kits (JDKs) and Java runtime engines (JREs), Java’s virtual machine debugging tools and Java based runtime engines.</li><li><a href="https://github.com/ScoopInstaller/Nonportable">nonportable</a> - Non-portable apps (may trigger UAC prompts).</li><li><a href="https://github.com/ScoopInstaller/PHP">php</a> - Installers for most versions of PHP.</li><li><a href="https://github.com/ScoopInstaller/Versions">versions</a> - Alternative versions of apps found in other buckets.</li></ul><h3 id="卸载软件"><a href="#卸载软件" class="headerlink" title="卸载软件"></a>卸载软件</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scoop uninstall &lt;app&gt;</span><br></pre></td></tr></table></figure><h3 id="切换软件版本"><a href="#切换软件版本" class="headerlink" title="切换软件版本"></a>切换软件版本</h3><p>假如你同时安装了多个环境，比如同时安装jdk11和jdk17，可以通过reset命令来切换版本。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到已安装的openjdk11</span></span><br><span class="line">scoop reset openjdk11</span><br></pre></td></tr></table></figure><hr><p>本文介绍了scoop的安装，卸载，以及一些常用的指令。本章有提及到不全面的地方，请参考<a href="https://scoop.sh/">scoop官网</a>或者<a href="https://github.com/ScoopInstaller/Scoop/wiki">scoop官方wiki</a>。</p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> scoop </tag>
            
            <tag> windows包管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>nginx实现正向代理</title>
      
      <link href="/2024/06/25/article2/"/>
      <url>/2024/06/25/article2/</url>
      
        <content type="html"><![CDATA[<p>本文介绍如何通过nignx实现正向代理。</p><span id="more"></span><p>nginx正向代理需要借助一个模块： <code>ngx_http_proxy_connect_module</code></p><p>该模块的<a href="https://github.com/chobits/ngx_http_proxy_connect_module">源码地址</a></p><p>我们需要先下载这个源码，然后通过编译的方式将其安装到nginx里。nginx安装方式有很多，比如通过apt直接安装，或者使用docker等。本文使用的nginx安装方式是源码编译安装。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol><li><p>下载ngx_http_proxy_connect_module模块。</p><p>直接clone其github仓库即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/chobits/ngx_http_proxy_connect_module.git</span><br></pre></td></tr></table></figure></li><li><p>下载nginx （v1.24.0）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget https://nginx.org/download/nginx-1.24.0.tar.gz</span><br><span class="line"><span class="comment"># 解压</span></span><br><span class="line">tar -zxvf nginx-1.24.0.tar.gz</span><br></pre></td></tr></table></figure><blockquote><p>安装nginx前，你可能需要一些前置的准备：</p><ul><li><p>安装gcc </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install build-essential</span><br></pre></td></tr></table></figure></li><li><p>安装pcre （正则库）</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install libpcre3 libpcre3-dev</span><br></pre></td></tr></table></figure></li><li><p>openssl</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-get install openssl libssl-dev</span><br></pre></td></tr></table></figure></li></ul></blockquote></li><li><p>打补丁</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/nginx-1.24.0 <span class="comment">#进入源码根目录</span></span><br><span class="line"><span class="comment"># 打补丁</span></span><br><span class="line">patch -p1 &lt; /path/to/ngx_http_proxy_connect_module/patch/proxy_connect_rewrite_102101.patch</span><br></pre></td></tr></table></figure><blockquote><p>这里我使用nginx1.24.0，需要的补丁是 proxy_connect_rewrite_102101.patch。</p><p>如果你使用其他nginx版本，可以在ngx_http_proxy_connect_module模块的github仓库<a href="https://github.com/chobits/ngx_http_proxy_connect_module?tab=readme-ov-file#select-patch">查看对应的补丁</a>。只需要将上述 ‘proxy_connect_rewrite_102101.patch’ 替换为对应版本的补丁即可。</p></blockquote></li><li><p>编译nginx源码，安装nginx</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> /path/to/nginx-1.24.0</span><br><span class="line"><span class="comment"># 编译配置项</span></span><br><span class="line">./configure --add-module=../ngx_http_proxy_connect_module --with-http_ssl_module</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure><blockquote><p>通过编译安装的nginx主目录位置在： &#x2F;usr&#x2F;local&#x2F;nginx 下</p></blockquote></li><li><p>编辑配置文件 ，启用正向代理</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">worker_processes</span>  auto;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /usr/local/nginx/logs/<span class="literal">error</span>.log <span class="literal">warn</span>;</span><br><span class="line"><span class="attribute">pid</span>        /usr/local/nginx/logs/nginx.pid;</span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 在 http 节中添加配置</span></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置日志</span></span><br><span class="line">    <span class="attribute">log_format</span> main <span class="string">&#x27;<span class="variable">$remote_addr</span> - <span class="variable">$remote_user</span> [<span class="variable">$time_local</span>] &quot;<span class="variable">$request</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;<span class="variable">$status</span> <span class="variable">$body_bytes_sent</span> &quot;<span class="variable">$http_referer</span>&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;<span class="variable">$http_user_agent</span>&quot; &quot;<span class="variable">$http_x_forwarded_for</span>&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span> /usr/local/nginx/logs/access.log main;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置代理缓存</span></span><br><span class="line">    <span class="attribute">proxy_cache_path</span> /usr/local/nginx/cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=cache_zone:<span class="number">10m</span> max_size=<span class="number">1g</span> inactive=<span class="number">60m</span> use_temp_path=<span class="literal">off</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 配置正向代理</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">8888</span>; <span class="comment"># 你需要在对应的云主机ISP防火墙开放这个端口</span></span><br><span class="line">        <span class="attribute">resolver</span> <span class="number">223.5.5.5</span>; </span><br><span class="line"></span><br><span class="line">        <span class="comment"># 允许 CONNECT 方法</span></span><br><span class="line">        proxy_connect;</span><br><span class="line">        <span class="attribute">proxy_connect_allow</span>            all;</span><br><span class="line">        <span class="attribute">proxy_connect_connect_timeout</span>  <span class="number">10s</span>;</span><br><span class="line">        <span class="attribute">proxy_connect_read_timeout</span>     <span class="number">10s</span>;</span><br><span class="line">        <span class="attribute">proxy_connect_send_timeout</span>     <span class="number">10s</span>;</span><br><span class="line"></span><br><span class="line">        <span class="section">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://<span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> Host <span class="variable">$host</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Real-IP <span class="variable">$remote_addr</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span> X-Forwarded-Proto <span class="variable">$scheme</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在win上配置代理，填入云主机的ip地址和端口即可。</p></li></ol><h2 id="已经安装了nginx？"><a href="#已经安装了nginx？" class="headerlink" title="已经安装了nginx？"></a>已经安装了nginx？</h2><p>上面是从头开始安装nginx的例子。 如果你的云主机上已经存在了nginx，但是不想重装，可以通过平滑升级方式实现。</p><h3 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>首先查看你当前安装的nginx包含哪些配置项</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/nginx/sbin/nginx -V</span><br></pre></td></tr></table></figure><p>记住<code>configure arguments:</code> 后面的内容， 我们需要保留这些 配置项，这样才不会影响你原来的nginx</p></li><li><p>进入新下载的nginx源码目录， 通过configure配置新的配置项，这个配置项会覆盖掉原来的配置。因此把原来的 配置加上，再添加你想要的 其他模块。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进入源码目录</span></span><br><span class="line"><span class="built_in">cd</span> /path/to/nginx-1.24.0</span><br><span class="line"><span class="comment"># 编译配置项   </span></span><br><span class="line"><span class="comment"># xxxxxxxxxxx 指的是之前让你记下的，你原来nginx的配置项，在此基础上添加新的依赖。</span></span><br><span class="line">./configure xxxxxxxxxxx --add-module=../ngx_http_proxy_connect_module</span><br><span class="line"><span class="comment"># 编译</span></span><br><span class="line">make</span><br></pre></td></tr></table></figure></li><li><p>将 objs 目录下，编译好的nginx二进制文件复制到nginx的安装目录下的&#x2F;sbin里。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> objs</span><br><span class="line"><span class="built_in">cp</span> nginx /usr/local/nginx/sbin</span><br></pre></td></tr></table></figure></li><li><p>回到源码的目录，执行make upgrade指令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/nginx-1.24.0</span><br><span class="line">make  upgrade</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>如果在执行make upgrade指令时报错： make: *** [Makefile:22：upgrade] 错误 1</p><p>尝试先kill掉原来的nginx进程，然后使用绝对路径来启动新的nginx：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 直接执行</span></span><br><span class="line">/usr/local/nginx/sbin/nginx</span><br></pre></td></tr></table></figure><p>之后再执行 make upgrade 应该不会有问题了。</p></blockquote><ol start="5"><li>安装完ngx_http_proxy_connect_module模块后，剩下的就是配置nginx.conf了，和上面一样，不再赘述。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> nginx </tag>
            
            <tag> 正向代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      
        <title>通过frp搭建自己的内网穿透服务</title>
      
      <link href="/2024/06/24/article1/"/>
      <url>/2024/06/24/article1/</url>
      
        <content type="html"><![CDATA[<p>本文介绍如何通过frp在自己的云服务器上搭建内网穿透服务，提供对外暴露的web服务。</p><p>内网穿透可以将本机的服务通过云服务器拥有的公有ip暴露到公网上供他人访问，应用场景有很多，比如做微信小程序开发时需要调试接口，或者向别人演示自己还未正式上线的小demo等。</p><p>在阅读本文内容之前，需要有一些前置准备：</p><ul><li>你拥有一个域名</li><li>你拥有一台具有公网ip地址的云主机</li></ul><span id="more"></span><h2 id="frp"><a href="#frp" class="headerlink" title="frp"></a>frp</h2><p>frp 是一款高性能的反向代理应用，专注于内网穿透。它支持多种协议，包括 TCP、UDP、HTTP、HTTPS 等，并且具备 P2P 通信功能。使用 frp，您可以安全、便捷地将内网服务暴露到公网，通过拥有公网 IP 的节点进行中转。</p><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>如果你是win系统，可以通过frp的<a href="https://github.com/fatedier/frp/releases">github releases</a>点击下载文件。</p><p>如果你是linux系统，你可以通过wget下载:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.58.1/frp_0.58.1_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>这里以win为例，下载完压缩包解压之后，你会看到如下的目录结构：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--frp_0.58.1_windows_amd64</span><br><span class="line">|-----frpc.toml</span><br><span class="line">|-----frpc.exe</span><br><span class="line">|-----frps.exe</span><br><span class="line">|-----frps.toml</span><br><span class="line">|-----LICENSE</span><br></pre></td></tr></table></figure><p>这里介绍一下，这个frpc.toml是客户端的配置文件，客户端指的是你需要进行内网穿透的机器。c就是client的意思。frpc.exe就是客户端的frp程序的启动文件。</p><p>frps.toml就是源服务器的配置文件，源服务器指的就是你的云服务器（拥有公网ip的）。同理，这个s就是source的意思。</p><p>那其实我们现在用的win机器，只需要保留frpc.toml和frpc.exe就行了，剩下的frps.toml和frps.exe可以删除掉。因为云服务器使用linux系统这个exe他也用不了，所以我们在云服务器上还需要从giithub上下载这个frp的文件。</p><p>同样的，在云服务器上下载了文件后，也可以删除掉frpc.toml和frpc，只需要保留frps.toml和frps即可。</p><p>接下来介绍具体操作步骤：</p><h3 id="对于客户端（win机器）"><a href="#对于客户端（win机器）" class="headerlink" title="对于客户端（win机器）"></a>对于客户端（win机器）</h3><ol><li><p>通过<a href="https://github.com/fatedier/frp/releases">github releases</a>下载文件</p></li><li><p>保留文件中的<code>frpc.toml</code>和<code>frpc.exe</code>即可</p></li><li><p>配置<code>frpc.toml</code></p></li><li><p>启动frpc服务</p></li></ol><h3 id="对于云主机（linux机器）"><a href="#对于云主机（linux机器）" class="headerlink" title="对于云主机（linux机器）"></a>对于云主机（linux机器）</h3><ol><li><p>通过sh命令获取frp文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.58.1/frp_0.58.1_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>保留文件中的<code>frps.toml</code>和<code>frps</code>即可</p></li><li><p>配置<code>frps.toml</code></p></li><li><p>启动frps服务</p></li></ol><p>如果你不想每次都进入frp安装目录下通过 <code>xxx/frps -c xxx/frps.toml</code> 来启动的话，可以通过<code>systemd</code>来添加frp服务，通过<code>systemctl</code>统一管理。具体步骤如下：</p><ol><li><p>在<code>/lib/systemd/system/</code>下创建 <code>frps.service</code>文件, 内容如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line"><span class="comment"># 服务名称，可自定义</span></span><br><span class="line">Description = frp server</span><br><span class="line">After = network.target syslog.target</span><br><span class="line">Wants = network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type = simple</span><br><span class="line"><span class="comment"># 启动frps的命令，需修改为您的frps的安装路径</span></span><br><span class="line">ExecStart = /path/to/frps -c /path/to/frps.toml</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy = multi-user.target</span><br></pre></td></tr></table></figure></li><li><p>通过systemd管理frps</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置自启动</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> frps</span><br><span class="line"><span class="comment"># 启动frp</span></span><br><span class="line">sudo systemctl start frps</span><br><span class="line"><span class="comment"># 停止frp</span></span><br><span class="line">sudo systemctl stop frps</span><br><span class="line"><span class="comment"># 重启frp</span></span><br><span class="line">sudo systemctl restart frps</span><br><span class="line"><span class="comment"># 查看frp状态</span></span><br><span class="line">sudo systemctl status frps</span><br></pre></td></tr></table></figure></li></ol><h2 id="对外提供web服务"><a href="#对外提供web服务" class="headerlink" title="对外提供web服务"></a>对外提供web服务</h2><ol><li><p>在云主机上配置frps.toml</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bindPort = 7000</span><br><span class="line">vhostHTTPPort = 8080</span><br></pre></td></tr></table></figure></li><li><p>在win机器（客户端）上配置frpc.toml</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">serverAddr = <span class="string">&quot;x.x.x.x&quot;</span>  &lt;-云主机公网ip地址</span><br><span class="line">serverPort = 7000</span><br><span class="line"></span><br><span class="line">[[proxies]]</span><br><span class="line">name = <span class="string">&quot;web&quot;</span></span><br><span class="line"><span class="built_in">type</span> = <span class="string">&quot;http&quot;</span></span><br><span class="line">localPort = 80   &lt;-暴露本机80端口的服务</span><br><span class="line">customDomains = [<span class="string">&quot;www.yourdomain.com&quot;</span>]</span><br><span class="line"></span><br><span class="line">[[proxies]]</span><br><span class="line">name = <span class="string">&quot;web2&quot;</span></span><br><span class="line"><span class="built_in">type</span> = <span class="string">&quot;http&quot;</span></span><br><span class="line">localPort = 8080  &lt;-暴露本机8080端口的服务</span><br><span class="line">customDomains = [<span class="string">&quot;www.yourdomain2.com&quot;</span>]</span><br></pre></td></tr></table></figure><blockquote><p>记得把自己的域名解析到云主机上！</p></blockquote></li><li><p>启动服务</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">to/path/frps -c frps.toml</span><br></pre></td></tr></table></figure><p>或者 通过systemd</p></li></ol><p>​win机器同理，通过powershell或者cmd执行exe程序并通过 <code>-c</code> 指定应用的配置文件。</p><p>至此，内网穿透已经实现，你可以愉快的向别人分享你的demo啦！😊</p><hr><p>结尾附上<a href="https://gofrp.org/zh-cn/docs/">frp的官方文档</a>，本文还有些不完善的地方或者没有提到的功能，可以参考frp官方文档。</p>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frp </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>